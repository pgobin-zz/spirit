import { cassa } from '../config'
import { createSubscription, renewSubscription, removeSubscription } from '../utils/stripe'
import { schema } from '../schema'



/**
 *
 *
 * TODO: Cannot charge and not add to db...
 * Subscribe to a channel
 *
 *
 * @param req
 * @param res
 *
 */
const subscribe = async (req, res, next) => {
  if (req.body.unsubscribe === true) return next()


  // * (1) Renew or create
  // If is subscription in grace period, then subscription
  // can be renewed
  //
  // If is new subscription request or is one that has expired,
  // a new stripe subscription has to be created

  let renewed, created

  if (res.locals.subscription.isGracePeriod) {

    // Renewing subscription with id from getStatus() is why
    // ID is returned from the status object

    renewed = await renewSubscription(res.locals.subscription.subscriptionId)
    if (!renewed) return schema(res, 500, 'Error renewing subscription.')
  } else {
    created = await createSubscription(res.locals.subscription.customerId)
    if (!created) return schema(res, 500, 'Error creating subscription.')
  }

  let subscriptionId = created && created.id || renewed && renewed.id


  // * (2) Update database
  // subscriber_id              The user subscribing to the channel
  // channel_*                  The channel info
  // stripe_subscription_id     Subscriptoin ID generated by Stripe
  // ! expires                  Expire must always be reset

  try {
    let subscription = new cassa.instance.channel_subscribed({
      subscriber_id:            cassa.uuidFromString(req.user.channelId),
      subscribed_id:            res.locals.subscription.channel.id, // already uui
      subscribed_alias:         res.locals.subscription.channel.alias, // already array
      subscribed_name:          res.locals.subscription.channel.name, // already array
      stripe_subscription_id:   [subscriptionId],
      expires:                  null
    })

    await subscription.saveAsync()
  } catch (error) {
    return schema(res, 500, 'Error saving subscription.')
  }

  return schema(res, 200, 'Succesfully subscribed.')
}



/**
 *
 *
 * Check expiration column from database against current date
 * to see if subscription has expired.
 *
 * Expiration occurs when a user has cancelled a subscription
 * before the period for the month has ended, which means that
 * the subscription is cancelled, but the user has paid for the
 * month and still has access.
 *
 * Stripe provides an expiration date for when the subscription is
 * to fully end (i.e., the end of the pay period) and here we
 * check to see if that time has come.
 *
 * Property names in return object cannot conflict
 * with channel properties because they're all merged into
 * one flat object to return to the client. It's okay though
 * for now because this shouldn't be a problem but...
 *
 * TODO: consider subobjecting this in response schema
 *
 *
 * @param subscription
 *
 */
const getStatus = (subscription) => {
  let isGracePeriod = false

  if (subscription && subscription.expires) {
      const expires = new Date(subscription.expires)
      const now = new Date()
      // isExpired = now >= expires
      isGracePeriod = now < expires
  }

  return {
    isSubscribed: subscription && !subscription.expires,

    // Grace period means user unsubbed but already paid
    isGracePeriod: isGracePeriod,

    // Case in point. Can't be named id...
    subscriptionId: subscription && subscription.stripe_subscription_id[0]
  }
}



/**
 *
 *
 * Validate channel subscription request
 *
 * Subscription validates and then creates a Stripe subscription
 * charged to the user's payment source. If the user does not have a
 * payment ource, the function does nothing.
 *
 *
 * @param req
 * @param res
 *
 */
const verify = async (req, res, next) => {
  if (req.body.unsubscribe === true) return next()


  // * (1) Assert user isn't subscribing to self
  // Check that channel user wants to follow is not own body by
  // comparing JWT alias to requested alias in body.

  if (req.body.id === req.user.channelId) {
    return schema(res, 401, 'Cannot subscribe to self.')
  }


  // * (2) Assert user has payment method
  // Check that user has a Stripe customer ID in the database.
  // If so, then the user has added a payment source in the past
  // at least once.

  let user
  try {
    user = await cassa.instance.user.findOneAsync({
      id: cassa.uuidFromString(req.user.id)
    })
  } catch (error) {
    return schema(res, 500, 'Error querying user.')
  }
  if (!user.stripe_customer_id) {
    return schema(res, 401, 'No payment info found.')
  }


    // * (3) Assert requested channel exists
  // Check that the channel the user wants to subscribe to exists
  // in the database.

  let channel
  try {
    channel = await cassa.instance.channel.findOneAsync({
      id: cassa.uuidFromString(req.body.id)
    })
  } catch (error) {
    return schema(res, 500, 'Error querying channel.')
  }
  if (!channel) {
    return schema(res, 401, 'Channel doesn\'t exist.')
  }


   // * (4) Get any existing subscription
  // Check that the user is not already subscribed to the channel.
  // If the user is subscribed, we must validate the subscription
  // and check the expiration in order to see if the user is on access
  // grace period.

  let subscription
  try {
    subscription = await cassa.instance.channel_subscribed.findOneAsync({
      subscriber_id:      cassa.uuidFromString(req.user.channelId),
      subscribed_id:      cassa.uuidFromString(req.body.id)
    })
  } catch (error) {
    return schema(res, 500, 'Error querying subscription.')
  }


  // * (5) Get status of subscription
  // A grace period means a user has cancelled but has
  // paid through the month and so still gets access.
  //
  // If the user is requesting a renewal, we can simply renew
  // the Stripe subscription instead of creating a new one.
  // Note getStatus() always returns an object, so there's
  // no undefined risk here.

  res.locals.subscription = getStatus(subscription)
  res.locals.subscription.customerId = user.stripe_customer_id[0]
  res.locals.subscription.channel = channel

  if (res.locals.subscription.isSubscribed) {
    return schema(res, 401, 'Already subscribed.')
  }

  return next()
}



/**
 *
 *
 * Unsubscribe from channel
 *
 *
 * TODO: Cannot uncharge and not remove from db...
 * @param req
 * @param res
 *
 */
const unsubscribe = async (req, res) => {

  // * (1) Assert subscription exists
  // Make sure user is currently subscribed to channel

  let subscription
  try {
    subscription = await cassa.instance.channel_subscribed.findOneAsync({
      subscriber_id:      cassa.uuidFromString(req.user.channelId),
      subscribed_id:      cassa.uuidFromString(req.body.id)
    })
  } catch (error) {
    return schema(res, 500, 'Error querying subscription.')
  }
  if (!subscription) {
    return schema(res, 401, 'Not subscribed to channel.')
  }


  // * (2) Remove Stripe subscription

  const removed = await removeSubscription(subscription.stripe_subscription_id[0])
  if (!removed) return schema(res, 500, 'Error unsubscribing.')


  // * (3) Expire subscription in database
  // Create expiration date to add to database 'expires' field
  // Used to calculate if user is in grace period or expired

  const expiration = new Date(removed.current_period_end * 1000)

  try {
    let expiredSubscription = new cassa.instance.channel_subscribed({
      subscriber_id:      cassa.uuidFromString(req.user.channelId),
      subscribed_id:      cassa.uuidFromString(req.body.id),
      expires:            expiration
    })
    await expiredSubscription.saveAsync()
  } catch (error) {
    return schema(res, 500, 'Error saving subscription.')
  }

  return schema(res, 200, 'Successfully unsubscribed.')
}



export default {
  subscribe: subscribe,
  unsubscribe: unsubscribe,
  getStatus: getStatus,
  verify: verify
}
